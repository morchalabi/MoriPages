<!DOCTYPE html>
<html style="font-size: 16px;" lang="en"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <meta name="keywords" content="Post 1 Headline">
    <meta name="description" content="">
    <title>Deep Learning Through Artificial Neural Networks</title>
    <link rel="stylesheet" href="../nicepage.css" media="screen">
<link rel="stylesheet" href="../Post-Template.css" media="screen">
    <script class="u-script" type="text/javascript" src="../jquery.js" defer=""></script>
    <script class="u-script" type="text/javascript" src="../nicepage.js" defer=""></script>
    <meta name="generator" content="Nicepage 7.14.0, nicepage.com">
    
    
    
    <link id="u-page-google-font" rel="stylesheet" href="https://fonts.googleapis.com/css2?display=swap&amp;family=Roboto:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&amp;family=Open+Sans:ital,wght@0,300;0,400;0,500;0,600;0,700;0,800;1,300;1,400;1,500;1,600;1,700;1,800">
    <script type="application/ld+json">{
		"@context": "http://schema.org",
		"@type": "Organization",
		"name": "MoriPages"
}</script>
    <meta name="theme-color" content="#478ac9">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta data-intl-tel-input-cdn-path="intlTelInput/"></head>
  <body data-path-to-root="./" data-include-products="false" class="u-body u-clearfix u-xl-mode" data-lang="en"><header class="u-clearfix u-header u-header" id="header"><div class="u-clearfix u-sheet u-valign-middle-lg u-valign-middle-md u-valign-middle-sm u-valign-middle-xs u-sheet-1">
        <nav class="u-menu u-menu-one-level u-offcanvas u-menu-1" role="navigation">
          <div class="menu-collapse" style="font-size: 1rem; letter-spacing: 0px;">
            <a class="u-button-style u-custom-left-right-menu-spacing u-custom-padding-bottom u-custom-top-bottom-menu-spacing u-hamburger-link u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base" href="#" tabindex="-1" aria-label="Open menu" aria-controls="1352">
              <svg class="u-svg-link" viewBox="0 0 24 24"><use xlink:href="#menu-hamburger"></use></svg>
              <svg class="u-svg-content" version="1.1" id="menu-hamburger" viewBox="0 0 16 16" x="0px" y="0px" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg"><g><rect y="1" width="16" height="2"></rect><rect y="7" width="16" height="2"></rect><rect y="13" width="16" height="2"></rect>
</g></svg>
            </a>
          </div>
          <div class="u-custom-menu u-nav-container">
            <ul class="u-nav u-unstyled u-nav-1" role="menubar"><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base" href="../" style="padding: 10px 20px;">Home</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base" href="../About.html" style="padding: 10px 20px;">About</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base" href="../Contact.html" style="padding: 10px 20px;">Contact</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base" href="../Blog.html" style="padding: 10px 20px;">Blog</a>
</li></ul>
          </div>
          <div class="u-custom-menu u-nav-container-collapse" id="1352" role="region" aria-label="Menu panel">
            <div class="u-black u-container-style u-inner-container-layout u-opacity u-opacity-95 u-sidenav">
              <div class="u-inner-container-layout u-sidenav-overflow">
                <div class="u-menu-close" tabindex="-1" aria-label="Close menu"></div>
                <ul class="u-align-center u-nav u-popupmenu-items u-unstyled u-nav-2" role="menubar"><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link" href="../">Home</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link" href="../About.html">About</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link" href="../Contact.html">Contact</a>
</li><li role="none" class="u-nav-item"><a role="menuitem" class="u-button-style u-nav-link" href="../Blog.html">Blog</a>
</li></ul>
              </div>
            </div>
            <div class="u-black u-menu-overlay u-opacity u-opacity-70"></div>
          </div>
        </nav>
      </div></header>
    <section class="u-align-center u-clearfix u-container-align-center u-section-1" id="block-1">
      <div class="u-clearfix u-sheet u-valign-middle-md u-valign-middle-sm u-valign-middle-xs u-sheet-1"><!--post_details--><!--post_details_options_json--><!--{"source":""}--><!--/post_details_options_json--><!--blog_post-->
        <div class="u-container-style u-expanded-width u-post-details u-post-details-1">
          <div class="u-container-layout u-valign-middle u-container-layout-1"><!--blog_post_image-->
            <img alt="" class="u-blog-control u-expanded-width u-image u-image-default u-image-1" src="../images/thumbnail.png"><!--/blog_post_image--><!--blog_post_header-->
            <h2 class="u-blog-control u-text u-text-1">Deep Learning Through Artificial Neural Networks</h2><!--/blog_post_header--><!--blog_post_metadata-->
            <div class="u-blog-control u-metadata u-metadata-1"><!--blog_post_metadata_date--><span class="u-meta-date u-meta-icon">Oct 14, 2025</span><!--/blog_post_metadata_date--><!--blog_post_metadata_category--><span class="u-meta-category u-meta-icon"><a href="/blog/blog.html#/blog-1///5">ANN</a></span><!--/blog_post_metadata_category--><!--blog_post_metadata_comments--><span class="u-meta-comments u-meta-icon"><!--blog_post_metadata_comments_content-->Comments (0)<!--/blog_post_metadata_comments_content--></span><!--/blog_post_metadata_comments-->
            </div><!--/blog_post_metadata--><!--blog_post_content-->
            <div class="u-align-justify u-blog-control u-post-content u-text u-text-2 fr-view"><hr><h4><strong data-end="596" data-start="539" id="isPasted">1 Modeling the Brain: Translating Neurons into Networks&nbsp;</strong></h4><p>In <span style="font-weight: 700;">Fig. 1</span> each neuron, shown in a different color, represents a biological neuron that could receive distinct sensory inputs from different sources, such as the <span class="u-text-black">nose</span>, <span class="u-text-black">eye</span>, and <span class="u-text-black">tongue</span>. Each neuron processes its incoming signals through its <span class="u-text-palette-2-dark-1">dendrites</span>, integrates them in the <span class="u-text-palette-2-dark-1">soma</span> (cell body), and transmits its output through the <span class="u-text-palette-2-dark-1">axon</span> to the next neuron across a <span class="u-text-palette-2-dark-1">synapse</span>. Together, this network of interconnected neurons can combine multisensory information to make an integrated decision, such as identifying what type of food is being perceived based on smell, sight, and taste. This biological mechanism of signal integration and communication serves as the conceptual foundation for artificial neural networks.</p><p><br><img src="../images/neuron_2.png" width="350" style="width: 490px;" class="fr-dib fr-fic fr-fil"><strong data-end="91" data-start="78" id="isPasted">Fig. 1</strong> Structure and connectivity of biological neurons. Schematic illustration showing key components of neurons, including dendrites, soma, axon, and synapse. Neurons receive input signals through dendrites, integrate them in the soma, and transmit electrical impulses along the axon to other neurons via synapses, forming complex communication networks in the brain.</p><p><br><span style="font-weight: 700;">Fig. 2</span> illustrates how this biological inspiration translates into the structure of an <span class="u-text-palette-2-dark-1">artificial neural network (ANN)</span>. Each circle labeled \(f\)<span style="font-style: italic;">&nbsp;</span><!--[if !msEquation]--><!--[if !vml]--><!--[endif]--><!--[endif]-->represents an artificial neuron or activation function. Features \( x_1, x_2\) and \(x_3 \) correspond to input signals, analogous to sensory data, which are processed in the <span class="u-text-palette-2-dark-1">input layer</span> and passed to a <span class="u-text-palette-2-dark-1">hidden layer</span> where nonlinear transformations are applied. These transformed signals are then combined to produce a <span class="u-text-palette-2-dark-1">prediction (ŷ</span><!--[if !msEquation]--><!--[if !vml]--><!--[endif]--><!--[endif]--><span class="u-text-palette-2-dark-1">)</span> in the <span class="u-text-palette-2-dark-1">output</span><strong data-end="1304" data-start="1288"><span class="u-text-palette-2-dark-1">&nbsp;</span></strong><span class="u-text-palette-2-dark-1">layer</span>. The weighted connections between layers mimic how electrical impulses travel between neurons, enabling the ANN to learn complex relationships from input data and make intelligent predictions, much like the brain integrates sensory information to recognize and classify objects.</p><p><br></p><p><img src="../images/neuron_1.png" width="350" style="width: 556px;" class="fr-dib fr-fic fr-fil"><strong data-end="480" data-start="467" id="isPasted">Fig. 2</strong> Architecture of an artificial neural network (ANN) inspired by biological neurons. Diagram showing how input features \( x_1, x_2\) and \(x_3 \) are processed through interconnected layers of artificial neurons (<span style="font-style: italic;">f</span>) in a neural network. The input layer passes signals to a hidden layer that performs nonlinear transformations, leading to an output neuron that produces the prediction (ŷ), analogous to signal transmission and integration in biological neural systems.</p><hr><h4 dir="auto" id="isPasted"><span style="font-weight: 700;">2 Fundamentals of Scalar and Vector Functions</span></h4><h5 id="isPasted">Scalar Function, Scalar Field, Vector Function, and Vector Field</h5><p>A <span class="u-text-palette-2-dark-1">scalar function</span> (aka <span class="u-text-palette-2-dark-1">scalar-valued function</span>) like \( f(x,y) = x^2 + y^2 \) is a map \( f: \mathbb{R}^n \to \mathbb{R} \) that assigns a single real number (a scalar) to each point in its domain. A <span class="u-text-palette-2-dark-1">scalar field</span> is a physical or geometric interpretation of a scalar function; it assigns a scalar value to every point in space (or spacetime).</p><p>A <span class="u-text-palette-2-dark-1">vector function</span> (aka <span class="u-text-palette-2-dark-1">vector-valued function</span>) is a map \( \mathbf{F}: \mathbb{R}^n \to \mathbb{R}^m \) like \(\mathbf{F}(x,y) = \begin{bmatrix} x^2 + y^2 &amp; \sin(xy) \end{bmatrix}\) that assigns a vector in \( \mathbb{R}^m \) to each point in \( \mathbb{R}^n \). The input of a vector-valued function could be a scalar or a vector (that is, the dimension of the domain could be 1 or greater than 1); the dimension of the function’s domain has no relation to the dimension of its range. A <span class="u-text-palette-2-dark-1">vector field</span> is a vector function \( \mathbf{F}: \mathbb{R}^n \to \mathbb{R}^n \) that assigns a vector in \( \mathbb{R}^n \) to each point in space. In some contexts, the codomain could be \( \mathbb{R}^m \), but vector fields in \( \mathbb{R}^n \) typically have codomain \( \mathbb{R}^n \).</p><p>A <span class="u-text-palette-2-dark-1">linear vector function</span> can be expressed in terms of matrices. The linear case arises often in multiple regression analysis, where the \( 1 \times m \) vector \( \hat{\mathbf{y}} \) of predicted values of a dependent variable \( \mathbf{y} \) is expressed linearly in terms of an \( n \times 1 \) vector \( \mathbf{w} \) of estimated values of model parameters (\( \hat{\mathbf{y}}: \mathbb{R}^n \to \mathbb{R}^m \)):</p><p>\[\hat{\mathbf{y}}(\mathbf{w}) = \begin{bmatrix} \mathbf{w} \cdot X_1 &amp; \dots &amp; \mathbf{w} \cdot X_m \end{bmatrix} = \mathbf{w}^T X,\]</p><p>in which \( \mathbf{X} \) is an \( n \times m \) matrix of fixed (empirically based) numbers, \( \mathbf{X}_i \) is a column vector, and \( \cdot \) is the dot product.</p><p>Many vector-valued functions, like scalar-valued functions, can be differentiated by simply differentiating the components. In Cartesian coordinates, if \( \mathbf{F} = (F_1, F_2, \dots, F_m) \), where each \( F_i: \mathbb{R}^n \to \mathbb{R} \) (\( \mathbf{F}: \mathbb{R}^n \to \mathbb{R}^m \)) is a scalar function, the differential is represented by the <span class="u-text-palette-2-dark-1">Jacobian matrix</span>:</p><p>\[d\mathbf{F}_p = \begin{bmatrix}\frac{\partial F_1}{\partial x_1} &amp; \dots &amp; \frac{\partial F_1}{\partial x_n} \\\vdots &amp; \ddots &amp; \vdots \\\frac{\partial F_m}{\partial x_1} &amp; \dots &amp; \frac{\partial F_m}{\partial x_n}\end{bmatrix} = \begin{bmatrix} \nabla F_1 \\ \vdots \\ \nabla F_m \end{bmatrix},\]</p><p>where the partial derivative of a vector function \( \mathbf{F} \) with respect to a scalar variable \( x_j \) is defined as\[\frac{\partial \mathbf{F}}{\partial x_j} = \sum_{i=1}^m \frac{\partial F_i}{\partial x_j} \mathbf{e}_i.\]</p><p>The vectors \( \mathbf{e}_1, \mathbf{e}_2, \mathbf{e}_3 \) form an orthonormal basis fixed (like Cartesian coordinate system) in the reference frame in which the derivative is being taken.</p><h5>Spaces and Coordinate Systems</h5><p>When working with scalar-valued or vector-valued functions, it is essential to recognize that these functions can exist in a variety of mathematical spaces, each equipped with its own structure and compatible coordinate systems. For instance, functions may be defined on Euclidean spaces such as \( \mathbb{R}^2 \) or \( \mathbb{R}^3 \), on curved surfaces like spheres or manifolds, or even on abstract vector spaces where distance and direction are generalized. The choice of coordinate system, Cartesian, polar, cylindrical, or spherical, must be compatible with the geometry of the space and the behavior of the function. Scalar fields, which assign a single value to every point, and vector fields, which assign a vector to each point, both depend on how these coordinates are defined and transformed. For example, gradients, divergences, and curls take different forms under different coordinate systems, even though the underlying geometric quantities remain invariant. Thus, a clear understanding of the underlying space and its coordinate representation is fundamental for expressing, interpreting, and manipulating scalar and vector functions correctly in both mathematical and physical contexts.</p><h5>Level Set, Tangent Space, and Tangent Vector</h5><p><span class="u-text-palette-2-dark-1">Level set</span> (or <span class="u-text-palette-2-dark-1">contour</span>) at point \( \mathbf{x} \) is the set of all points in the scalar field where the function has the same constant value as \( f(\mathbf{x}) \). For example, on a topographic map (like mountains from above), these are the contour lines connecting points of equal elevation. \( \nabla f(\mathbf{x}) \) is sometimes called a <span class="u-text-palette-2-dark-1">tangent vector</span> at \( \mathbf{x} \), while ``Tangent'' here does not mean tangent to \( f \) or even its level set at point \( \mathbf{x} \). This is a common point of confusion. On the contrary, the gradient vector at a point is a normal (orthogonal) to the level set, passing through that point, and every vector tangent to it. In fact, in some geometric contexts, especially in differential geometry, every vector attached to a point, even a normal vector, formally lives in the <span class="u-text-palette-2-dark-1">tangent space</span> at that point. In a Euclidean space, the tangent space at a point \( \mathbf{x} \in \mathbb{R}^n \), denoted by \( T_{\mathbf{x}} \mathbb{R}^n \), is simply the space itself. For example, in 3D Euclidean space (\( \mathbb{R}^3 \)), the tangent space at any point \( (x, y, z) \) is just another copy of \( \mathbb{R}^3 \). This might seem trivial, but it becomes crucial when you consider more complex curved spaces (manifolds) where the tangent space at each point can be different.</p><h5>Directional Derivative</h5><p>The directional derivative of a scalar field \( f: \mathbb{R}^n \to \mathbb{R} \) in Euclidean space at a point \( \mathbf{x} \in \mathbb{R}^n \) in the direction of a vector \( \mathbf{v} \in \mathbb{R}^n \) is a measure of the rate of change of \( f \) along the direction \( \mathbf{v} \) and is defined as:</p><p>\[D_{\mathbf{v}} f(\mathbf{x}) = \lim_{h \to 0} \frac{f(\mathbf{x} + h \mathbf{v}) - f(\mathbf{x})}{h \|\mathbf{v}\|},\]</p><p>where:</p><ul><li>\( \mathbf{v} \in \mathbb{R}^n \) is an arbitrary nonzero vector and a tangent vector of the tangent space at \( \mathbf{x} \). To adjust a formula for the directional derivative to work for any vector, one must divide the expression by the magnitude of the vector, \( \|\mathbf{v}\| \). If \( \mathbf{v} \) is already a unit vector (\( \|\mathbf{v}\| = 1 \)), \( D_{\mathbf{v}} f(\mathbf{x}) \) gives the rate of change per unit distance in that direction. That’s why many mathematical texts assume that the directional vector is normalized, denoted by \( \hat{\mathbf{v}} \).</li><li>\( h \in \mathbb{R} \) is a scalar parameter.</li></ul><p>This definition is coordinate-free because it depends only on the Euclidean structure of \( \mathbb{R}^n \) (points, vectors, and the ability to add vectors and scale them) and the values of \( f \), without reference to any specific coordinate system like Cartesian or polar coordinates.</p><p>The directional derivative \( D_{\mathbf{v}} f(\mathbf{x}) \) may exist for a specific direction \( \mathbf{v} \) even if \( f \) is not differentiable at \( \mathbf{x} \). Differentiability of \( f \) at \( \mathbf{x} \) requires that the directional derivative exists for all directions \( \mathbf{v} \) and that the map \( \mathbf{v} \mapsto D_{\mathbf{v}} f(\mathbf{x}) \) is linear (i.e., \( D_{\mathbf{v}} f(\mathbf{x}) = \nabla f(\mathbf{x}) \cdot \mathbf{v} \)). If \( f \) is not differentiable, the directional derivative may exist in some directions but not others, or it may exist in all directions but fail to be linear. If \( f \) is differentiable at \( \mathbf{x} \), the directional derivative in any direction \( \mathbf{v} \) can be computed using the gradient \( \nabla f(\mathbf{x}) \), which exists and is a vector in \( \mathbb{R}^n \). The gradient is defined such that:</p><p>\[D_{\mathbf{v}} f(\mathbf{x}) = \nabla f(\mathbf{x}) \cdot \mathbf{v},\]</p><p>where \( \cdot \) is the Euclidean dot product. This follows because differentiability implies that the function’s rate of change is linear in the direction \( \mathbf{v} \), and the gradient \( \nabla f(\mathbf{x}) \) is the unique vector satisfying this for all \( \mathbf{v} \). In this case, the directional derivative is a linear functional on the tangent space, and its value depends smoothly on the direction. Directional derivative may also be denoted by \( D_{\mathbf{v}} f(\mathbf{x}) = \frac{\partial f(\mathbf{x})}{\partial \mathbf{v}} \).</p><p><span class="u-text-palette-2-dark-1">Del</span>, or <span class="u-text-palette-2-dark-1">nabla</span>, is an operator used in mathematics (particularly in vector calculus) as a <span class="u-text-palette-2-dark-1">vector differential operator</span>, usually represented by \( \nabla \). As a vector operator, it can act on scalar and vector fields in three different ways, giving rise to three different differential operations: (1) it can act on scalar fields (or vector fields component-wise) by a formal scalar multiplication (\( \text{grad} f = \nabla f \)), to give a vector field called the gradient, (2) it can act on vector fields by a formal dot product (\( \text{div} \mathbf{v} = \nabla \cdot \mathbf{v} \)) to give a scalar field called the divergence, (3) and lastly, it can act on vector fields by a formal cross product (\( \text{curl} \mathbf{v} = \nabla \times \mathbf{v} \)) to give a vector field called the curl. In the Cartesian coordinate system \( \mathbb{R}^n \) with coordinates \( (x_1, \dots, x_n) \) and standard basis \( \{\mathbf{e}_1, \dots, \mathbf{e}_n\} \), del is a vector operator whose \( x_1, \dots, x_n \) components are the partial derivative operators \( \frac{\partial}{\partial x_1}, \dots, \frac{\partial}{\partial x_n} \); that is,</p><p>\[\nabla = \sum_{i=1}^n \mathbf{e}_i \frac{\partial}{\partial x_i} = \left( \frac{\partial}{\partial x_1}, \dots, \frac{\partial}{\partial x_n} \right),\]</p><p>where the expression in parentheses is a row vector. Note that \( \mathbf{v} \cdot \nabla \) is also an operator that maps scalars to scalars. It can be extended to act on a vector field by applying the operator component-wise to each component of the vector.</p><h5>Gradient</h5><p>In Euclidean space \( \mathbb{R}^n \), equipped with the standard dot product, the gradient of a differentiable scalar field \( f: \mathbb{R}^n \to \mathbb{R} \) at a point \( \mathbf{x} \in \mathbb{R}^n \) is the unique vector \( \nabla f(\mathbf{x}) \in \mathbb{R}^n \) (a vector field) such that for every vector \( \mathbf{v} \in \mathbb{R}^n \) (a tangent vector at \( \mathbf{x} \)), the directional derivative of \( f \) at \( \mathbf{x} \) in the direction \( \mathbf{v} \) satisfies:</p><p>\[D_{\mathbf{v}} f(\mathbf{x}) = \nabla f(\mathbf{x}) \cdot \mathbf{v},\]</p><p>where:</p><ul><li>\( \cdot \) denotes the Euclidean dot product in \( \mathbb{R}^n \).</li><li>\( \mathbb{R}^n \) is both the space and its tangent space at \( \mathbf{x} \), so \( \mathbf{v} \) and \( \nabla f(\mathbf{x}) \) are vectors in \( \mathbb{R}^n \).</li></ul><p>This definition is coordinate-free because it relies only on: (i) the Euclidean vector space structure (addition, scaling, and the dot product), and (ii) the values of \( f \) and the directional derivatives, without reference to a specific coordinate system (e.g., Cartesian, polar). In the \( n \)-dimensional Cartesian coordinate system with a Euclidean metric, the gradient, if it exists at \( \mathbf{x} \), is given by:</p><p>\[\nabla f(\mathbf{x}) = \left( \frac{\partial f}{\partial x_1}(\mathbf{x}), \frac{\partial f}{\partial x_2}(\mathbf{x}), \dots, \frac{\partial f}{\partial x_n}(\mathbf{x}) \right).\]</p><p>The gradient \( \nabla f(\mathbf{x}) \) points in the direction in which \( f \) increases (positive values) most rapidly from \( \mathbf{x} \), while its magnitude, \( \|\nabla f(\mathbf{x})\| \), gives the rate of change of \( f \) in the direction of steepest ascent. The gradient thus plays a fundamental role in optimization theory, where it is used to minimize a function by gradient descent. The directional derivative, \( D_{\mathbf{v}} f(\mathbf{x}) = \nabla f(\mathbf{x}) \cdot \mathbf{v} = \|\nabla f(\mathbf{x})\| \|\mathbf{v}\| \cos \theta \), is equal to the maximum value \( \|\nabla f(\mathbf{x})\| \) when \( \mathbf{v} \) (normalized) is aligned with \( \nabla f(\mathbf{x}) \).</p><hr><h4><span style="font-weight: 700;">3 Mathematical Representation of Model Parameters and Data Structure</span></h4><p>This schematic below (<span style="font-weight: 700;">Fig. 3</span>) shows how input features and parameters interact in supervised learning. The blue-shaded cells represent model parameters—the weights (wiw_iwi) and bias (bbb)—while the orange-shaded cells denote the predicted outputs (y^i\hat{y}^iy^i). Each column corresponds to a training example, and each row corresponds to a feature, illustrating how examples and their labels are organized within the data matrix used for learning.</p><p><br></p><p><img src="../images/table.png" width="350" style="width: 350px;" class="fr-dib fr-fic fr-fil"></p><p><strong data-end="695" data-start="682" id="isPasted">Fig. 3</strong> Tabular representation of input data, parameters, and predictions.</p><p><br></p><p dir="auto" id="isPasted">\( X = \begin{bmatrix} \mathbf{x}^{(1)} &amp; \cdots &amp; \mathbf{x}^{(m)} \end{bmatrix}_{n \times m}
\)</p><p>\(\mathbf{y} = \begin{bmatrix} y^{(1)} &amp; \cdots &amp; y^{(m)} \end{bmatrix}_{1 \times m}\)</p><p>\(\mathbf{w} = \begin{bmatrix} w_1 &amp; \cdots &amp; w_m \end{bmatrix}_{1 \times m}\)</p><p>\(\hat{\mathbf{y}} = \mathbf{F}(\mathbf{w}, b) = \begin{bmatrix} \hat{y}^{(1)} = F_1 (\mathbf{w}, b) &amp; \cdots &amp; \hat{y}^{(m)} = F_m (\mathbf{w}, b) \end{bmatrix}_{1 \times m}\)</p><p>\(\mathbf{L} = \mathbf{G}(\mathbf{w}, b) = \begin{bmatrix} L^{(1)} = G_1 (\mathbf{w}, b) &amp; \cdots &amp; L^{(m)} = G_m (\mathbf{w}, b) \end{bmatrix}_{1 \times m}\)</p><p>\(C = H(\mathbf{w}, b)\)</p><p>where:</p><ul><li>\( X \) is the table of examples (a matrix),</li><li>\( \mathbf{x}^{(i)} \) is the i-th example (a scalar column vector),</li><li>\( \mathbf{x}_j \) is the j-th feature (a scalar row vector),</li><li>\( \mathbf{y} \) is the labels (a scalar row vector),</li><li>\( y^{(i)} \) is the i-th example’s label (a scalar)</li><li>\( \mathbf{w} \) is the coeffects (a scalar column vector),</li><li>\( w_j \) is the j-th coefficient (a scalar),\item \( b \) is the bias (a scalar),</li><li>\( \hat{\mathbf{y}} \) is the predicted labels (a scalar row vector),</li><li>\( \mathbf{F} \) is a row vector field (\( \mathbf{F}: \mathbb{R}^{m+1} \to \mathbb{R}^m \)),</li><li>\( F_i \) is the i-th scalar field component of \( \mathbf{F} \),</li><li>\( \mathbf{L} \) is the loss values (a scalar row vector),</li><li>\( \mathbf{G} \) is a row vector field (\( \mathbf{G}: \mathbb{R}^m \to \mathbb{R}^m \)),</li><li>\( G_i \) is the i-th scalar field component of \( \mathbf{G} \),</li><li>\( C \) is the cost (a scalar) and\item \( H \) is a scalar field (\( H: \mathbb{R}^m \to \mathbb{R}^1 \)).</li></ul><p>Given fixed \( \mathbf{X} \) and \( \mathbf{y} \), the task is to learn some \( \mathbf{w} \) and \( b \) that minimize \( C \). As learning (training the model) progresses, \( \mathbf{w} \), \( b \) and consequently \( \hat{\mathbf{y}} \) change together at each iteration. At the end of each iteration, \( \mathbf{L} \) and \( C \) are computed. While \( \mathbf{L} \) measures the distance between \( \mathbf{y} \) and \( \hat{\mathbf{y}} \) for an example, \( C \) measures the overall loss across all examples. There are several options for \( \mathbf{L} \) like the cross-entropy loss (aka log loss) \( L = G(\mathbf{w}, b) = -y \log(\hat{y}) - (1 - y) \log(1 - \hat{y}) \), for binary classification, while \( C \) is usually the mean over \( \mathbf{L} \), i.e. \[C = H(\mathbf{w}, b) = \frac{1}{m} \sum_{i=1}^m L^{(i)}.\]There are also several possibilities for \( \mathbf{F} \) like the linear transformation \( \hat{\mathbf{y}} = \mathbf{F}(\mathbf{w}, b) = \mathbf{w}^T \mathbf{X} + b \), as in multiple regression analysis, or the sigmoid function of this transformation \[\hat{\mathbf{y}} = \mathbf{F}(\mathbf{w}, b) = \sigma(\mathbf{w}, b) = \frac{1}{1 + e^{\mathbf{w}^T \mathbf{X} + b}},\]as in classification problems. In ANN terminology, \( \mathbf{F} \) is called activation as its job is to excite/activate a neuron.</p><hr><h4><span style="font-weight: 700;">4 The Gradient Descent Updates for \( \mathbf{w} \) and \( b \)</span></h4><p>The <span class="u-text-palette-2-dark-1">gradient descent</span> update rules for the weight vector \( \mathbf{w} \) and bias \( b \) are</p><p>\[\ddot{\mathbf{w}} = \dot{\mathbf{w}} - \beta \nabla H(\dot{\mathbf{w}})\]\[\ddot{b} = \dot{b} - \beta \nabla H(\dot{b}),\]</p><p>where \( \beta \) is the <span class="u-text-palette-2-dark-1">learning rate</span> and</p><p>\[\nabla H(\mathbf{w}) = \left( \frac{\partial H(\mathbf{w})}{\partial w_1}, \dots, \frac{\partial H(\mathbf{w})}{\partial w_n} \right).\]</p><p>If \( H(\mathbf{w}) = \frac{1}{m} \sum_{i} L^{(i)} \), then</p><p>\[\nabla H(\mathbf{w}) = \frac{1}{m} \left( \sum_{i} \frac{\partial L^{(i)}}{\partial w_1}, \dots, \sum_{i} \frac{\partial L^{(i)}}{\partial w_n} \right).\]</p><p>Although the gradient \( \nabla H(\mathbf{w}) \) points in the direction of steepest ascent of \( H \), the subtraction term \( (-\beta \nabla H) \) flips this direction, guiding the parameters toward the minimum of \( H(\mathbf{w}) \), hence the name gradient descent.</p><p>Using binary cross-entropy loss \( \mathbf{L} = \mathbf{G}(\mathbf{w}, b) = -\mathbf{y} \log(\mathbf{\hat{y}}) - (1 - \mathbf{y}) \log(1 - \mathbf{\hat{y}}) \), where \( \mathbf{L} \) depends on \( \mathbf{\hat{y}} \) and \( \mathbf{\hat{y}} \) depends on \( \mathbf{w} \), the chain rule gives:</p><p>\[\frac{\partial L^{(i)}}{\partial w_j} = \frac{\partial L^{(i)}}{\partial \hat{y}^{(i)}} \cdot \frac{\partial \hat{y}^{(i)}}{\partial w_j} = \frac{\hat{y}^{(i)} - y^{(i)}}{\hat{y}^{(i)} (1 - \hat{y}^{(i)})} \cdot \frac{\partial \hat{y}^{(i)}}{\partial w_j}.\]</p><p>Assuming \( \mathbf{\hat{y}} = \mathbf{F}(\mathbf{w}, b) = \sigma(\mathbf{w}^T X + b) \) for binary classification, then:</p><p>\[\frac{\partial L^{(i)}}{\partial w_j} = \frac{\hat{y}^{(i)} - y^{(i)}}{\hat{y}^{(i)} (1 - \hat{y}^{(i)})} \cdot \left( x_j^{(i)} \hat{y}^{(i)} (1 - \hat{y}^{(i)}) \right) = (\hat{y}^{(i)} - y^{(i)}) x_j^{(i)}.\]</p><p>Substituting into \( \nabla H(\mathbf{w}) \):</p><p><span class="u-text-palette-2-dark-1">\[\nabla H(\mathbf{w}) = \frac{1}{m} \left( \sum x_1^{(i)} (\hat{y}^{(i)} - y^{(i)}), \dots, \sum x_n^{(i)} (\hat{y}^{(i)} - y^{(i)}) \right) = X_{n \times m} (\hat{\mathbf{y}} - \mathbf{y})_{1 \times m}^T.\]</span></p><p>Similarly,</p><p>\[\frac{\partial L^{(i)}}{\partial b} = \frac{\hat{y}^{(i)} - y^{(i)}}{\hat{y}^{(i)} (1 - \hat{y}^{(i)})} \cdot \hat{y}^{(i)} (1 - \hat{y}^{(i)}) = \hat{y}^{(i)} - y^{(i)},\]</p><p>so</p><p><span class="u-text-palette-2-dark-1">\[\nabla H(b) = \frac{1}{m} \sum (\hat{y}^{(i)} - y^{(i)}).\]</span></p><h5>Why is \( \frac{\partial \hat{y}^{(i)}}{\partial w_j} = \hat{y}^{(i)} (1 - \hat{y}^{(i)}) x_j^{(i)} \)?</h5><p>Let \( u^{(i)} = \mathbf{w}^T \mathbf{x}^{(i)} + b \). Then</p><p>\[\frac{\partial u^{(i)}}{\partial w_j} = x_j^{(i)},\]</p><p>since \( \frac{\partial u^{(i)}}{\partial w_j} = \frac{\partial}{\partial w_j} (w_1 x_1^{(i)} + \dots + w_j x_j^{(i)} + \dots + w_n x_n^{(i)} + b) = x_j^{(i)} \).</p><p>It is known that \( \frac{\partial \sigma(u^{(i)})}{\partial u^{(i)}} = \sigma(u^{(i)}) (1 - \sigma(u^{(i)})) \). By the chain rule,</p><p>\[\frac{\partial \sigma(u^{(i)})}{\partial w_j} = \frac{\partial \sigma(u^{(i)})}{\partial u^{(i)}} \cdot \frac{\partial u^{(i)}}{\partial w_j} = \sigma(u^{(i)}) (1 - \sigma(u^{(i)})) \cdot x_j^{(i)} = x_j^{(i)} \hat{y}^{(i)} (1 - \hat{y}^{(i)}).\]</p><p>Similarly, \( \frac{\partial \sigma(u^{(i)})}{\partial b} = \hat{y}^{(i)} (1 - \hat{y}^{(i)}) \).</p><p>Note that in this context, \( u^{(i)} \) and \( \hat{y}^{(i)} \) are not scalars but represent independent and dependent variables, respectively, analogous to \( x \) and \( y \) in \( y = f(x) = \sin(x) \).</p><hr><p><br></p></div><!--/blog_post_content-->
          </div>
        </div><!--/blog_post--><!--/post_details-->
      </div>
    </section>
    
    
    
    <footer class="u-align-center u-clearfix u-container-align-center u-footer u-grey-80 u-footer" id="footer"><div class="u-clearfix u-sheet u-sheet-1">
        <p class="u-small-text u-text u-text-variant u-text-1">Personal website of Mori Chalabi, PhD, 2025</p>
      </div></footer>
    <section class="u-backlink u-clearfix u-grey-80"></section>
  
</body></html>